\documentclass[11pt,a4paper]{article}

\usepackage[margin=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}

\title{Practical Work 1 -- TCP File Transfer}
\author{Your Group Name \\ Distributed Systems -- USTH}
\date{\today}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  language=C
}

\begin{document}
\maketitle

\section{Introduction}

The purpose of this practical work is to build a simple command--line
\textbf{one-to-one file transfer} application using TCP.
The system consists of one server and one client. The client reads a local file
and sends it to the server over a reliable byte stream.
The server receives the data and stores it in a file on disk.

Our implementation is based on the socket API provided by Linux and reuses the
basic structure of the chat example provided in the course.
We extend it with a small application-level protocol specific to file transfer.

\section{Protocol Design}

We design a very small binary protocol on top of TCP. The client always
initiates the transfer and the server only receives files.
The content of the TCP byte stream is organised as follows:

\begin{enumerate}
  \item \textbf{Command header}:
    the client first sends the ASCII string \verb|SEND_FILE\n| (10 bytes).
    This allows the the server to quickly check that the client is using
    the expected protocol.

  \item \textbf{File name length}:
    a 32-bit unsigned integer in network byte order (big endian)
    giving the length $N$ of the file name.

  \item \textbf{File name}:
    $N$ bytes containing the file name (without a terminating
    \verb|\0|). The server uses this value when creating the output file.

  \item \textbf{File size}:
    a 64-bit unsigned integer in network byte order specifying the size
    of the file in bytes.

  \item \textbf{File data}:
    exactly \emph{size} bytes of raw file content.
\end{enumerate}

If the server receives an invalid command or the stream ends before all
expected bytes are read, the server aborts the transfer and closes the
connection.

Figure~\ref{fig:protocol} illustrates the structure of the messages.

\begin{figure}[h]
  \centering
  \fbox{\parbox{0.9\linewidth}{
    \textbf{Client} $\rightarrow$ \textbf{Server}:

    \begin{itemize}
      \item ``SEND\_FILE\textbackslash n'' (10 bytes)
      \item filename length (uint32\_t, network order)
      \item filename (N bytes)
      \item file size (uint64\_t, network order)
      \item file content (``size'' bytes)
    \end{itemize}
  }}
  \caption{Application-level protocol for TCP file transfer.}
  \label{fig:protocol}
\end{figure}

\section{System Organisation}

The system follows a classical client--server architecture:

\begin{itemize}
  \item \textbf{Server}:
    \begin{itemize}
      \item Opens a listening socket on a given TCP port.
      \item Uses \verb|bind()| and \verb|listen()| to attach the socket
            to the local address.
      \item Calls \verb|accept()| to handle incoming connections.
      \item For each connection, receives exactly one file and saves it.
    \end{itemize}

  \item \textbf{Client}:
    \begin{itemize}
      \item Resolves the server address and port.
      \item Opens the local file and determines its size.
      \item Connects to the server with \verb|connect()|.
      \item Sends the protocol header and the file data.
    \end{itemize}
\end{itemize}

For simplicity, our server is single-threaded and processes one client at a
time. Extending it to accept multiple clients in parallel (using
\verb|fork()|, threads or \verb|select()|) is left as future work.

Figure~\ref{fig:architecture} shows the global organisation.

\begin{figure}[h]
  \centering
  \fbox{\parbox{0.9\linewidth}{
    \begin{itemize}
      \item Client: reads local file, sends metadata and data over a TCP socket.
      \item Network: reliable byte stream provided by TCP.
      \item Server: receives metadata, creates a new file and writes the data.
    \end{itemize}
  }}
  \caption{Overall architecture of the file transfer system.}
  \label{fig:architecture}
\end{figure}

\section{Implementation Overview}

We use a few small helper functions shared by both programs:

\begin{itemize}
  \item \verb|readn()| and \verb|writen()|, which repeatedly call
        \verb|read()|/\verb|write()| until all requested bytes have been
        transferred.
  \item \verb|htonll()| and \verb|ntohll()| to convert 64-bit integers
        between host and network byte order.
\end{itemize}

\subsection{Server}

The server program expects one command line argument: the TCP port on which
it should listen. After initialisation, it enters an infinite loop where it
accepts a connection and receives exactly one file.

Listing~\ref{lst:server} shows the core of the handler that operates on a
connected socket.

\begin{lstlisting}[caption={Server-side handler for receiving a file},
                 label={lst:server}]
void handle_client(int connfd) {
    char command[16] = {0};
    if (readn(connfd, command, 10) != 10) {
        fprintf(stderr, "Invalid command header\n");
        return;
    }
    if (strncmp(command, "SEND_FILE\n", 10) != 0) {
        fprintf(stderr, "Unknown command\n");
        return;
    }

    uint32_t name_len_n;
    if (readn(connfd, &name_len_n, sizeof(name_len_n)) != sizeof(name_len_n)) {
        fprintf(stderr, "Failed to read name length\n");
        return;
    }
    uint32_t name_len = ntohl(name_len_n);

    char *filename = malloc(name_len + 1);
    if (!filename) {
        perror("malloc");
        return;
    }
    if (readn(connfd, filename, name_len) != name_len) {
        fprintf(stderr, "Failed to read file name\n");
        free(filename);
        return;
    }
    filename[name_len] = '\0';

    uint64_t size_n;
    if (readn(connfd, &size_n, sizeof(size_n)) != sizeof(size_n)) {
        fprintf(stderr, "Failed to read file size\n");
        free(filename);
        return;
    }
    uint64_t file_size = ntohll(size_n);

    FILE *out = fopen(filename, "wb");
    if (!out) {
        perror("fopen");
        free(filename);
        return;
    }

    char buffer[4096];
    uint64_t remaining = file_size;
    while (remaining > 0) {
        size_t chunk = remaining < sizeof(buffer) ? remaining : sizeof(buffer);
        ssize_t n = read(connfd, buffer, chunk);
        if (n <= 0) break;
        fwrite(buffer, 1, n, out);
        remaining -= n;
    }

    fclose(out);
    free(filename);
}
\end{lstlisting}

\subsection{Client}

The client program takes three arguments: server IP address, server port and
the path to the local file to send.

Its main steps are:

\begin{enumerate}
  \item Open the file and determine its size with \verb|fstat()|.
  \item Create a TCP socket and connect to the server.
  \item Send the command header, file name, file size and finally the data.
\end{enumerate}

Listing~\ref{lst:client} shows the core function that performs the transfer.

\begin{lstlisting}[caption={Client-side routine for sending a file},
                 label={lst:client}]
int send_file(int sockfd, const char *path) {
    const char *name = strrchr(path, '/');
    name = (name == NULL) ? path : name + 1;

    int fd = open(path, O_RDONLY);
    if (fd < 0) {
        perror("open");
        return -1;
    }

    struct stat st;
    if (fstat(fd, &st) < 0) {
        perror("fstat");
        close(fd);
        return -1;
    }
    uint64_t size = (uint64_t) st.st_size;

    if (writen(sockfd, "SEND_FILE\n", 10) != 10) return -1;

    uint32_t len = strlen(name);
    uint32_t len_n = htonl(len);
    if (writen(sockfd, &len_n, sizeof(len_n)) != sizeof(len_n)) return -1;

    if (writen(sockfd, name, len) != (ssize_t)len) return -1;

    uint64_t size_n = htonll(size);
    if (writen(sockfd, &size_n, sizeof(size_n)) != sizeof(size_n)) return -1;

    char buffer[4096];
    ssize_t n;
    while ((n = read(fd, buffer, sizeof(buffer))) > 0) {
        if (writen(sockfd, buffer, n) != n) {
            close(fd);
            return -1;
        }
    }

    close(fd);
    return 0;
}
\end{lstlisting}

\section{Testing}

We tested the system on two Linux machines connected in a local network:

\begin{itemize}
  \item Transfer of small text files (1--10~KB) to verify that names and
        contents are correct.
  \item Transfer of larger binary files (several MB) to measure the time and
        check robustness.
  \item Error cases (non-existing input file on the client side, interrupted
        connection) to observe the behaviour.
\end{itemize}

We used the \verb|md5sum| command on both sides to ensure that the original and
received files have identical checksums.

\section{Work Distribution}

The work within the group was organised as follows:

\begin{itemize}
  \item \textbf{Member 1}: protocol design and client implementation.
  \item \textbf{Member 2}: server implementation and error handling.
  \item \textbf{Member 3}: testing on different file sizes and preparation
        of this \LaTeX{} report.
\end{itemize}

All members participated in debugging and reviewing the code.

\section{Conclusion}

This practical work allowed us to revisit the basic socket API and to
experiment with a simple application-level protocol on top of TCP.
Designing our own protocol forced us to think about message framing, byte
ordering and error handling, which are essential in real distributed systems.

Future improvements include supporting multiple concurrent clients, adding
progress information on the client side, and implementing integrity checks
directly in the protocol.

\end{document}
